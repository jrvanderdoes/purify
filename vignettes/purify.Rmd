---
title: "purify"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{purify}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

Welcome to `purify'! This vignette will outline the main functions and offer many valuable simulations for these funtions. Real data examples can be found in other vignettes.

`Purify' comes from its purpose of permutation tests and statification for data. It can be used to purify data and mitigate confounding effects, particularly when looking at strata which are much smaller than other strata.

The data can be found on GitHub and can be loaded as:
```{r setup}
library(purify)
```

# Using resample_function()

In this vignette, we explore the use of this package with simulated data. The function \code{resample_function()} has four options, 'simple', 'stratify', 'sliding', 
and 'segment'. We follow these for this vignette.


## Simple Permutation

Consider a simple data set as generated below.
```{r simple_generate}
set.seed(12345)
n <- 100

data_simple <- data.frame('y'=rep(NA,n),
                          'x'=rnorm(n),
                          'z'=rexp(n))
outliers <- runif(3,1,n)
data_simple[outliers,'x'] <- 25*data_simple[outliers,'x']
data_simple[outliers,'z'] <- 10*data_simple[outliers,'z']
errors <- rnorm(n,0,5)
errors[outliers] <- 10*errors[outliers]
data_simple$y <- 1 + 2*data_simple$x - 3*data_simple$z + data_simple$x*data_simple$z + errors

```

Suppose we are interested in the regression $$y\sim \beta_0+\beta_1x+\beta_2z+\beta_3xz$$. This can be codified as follows, noting that the first value of the output data.frame is the estimates.
```{r simple_function}
simple_function <- function(X){
  reg <- lm(y~x*z, data=X)
  
  coef(summary(reg))
}
```

The model on the original data is computed.
```{R simple_regression}
set.seed(12345)
simple_function(data_simple)
```
This simulation returns value which are similar but are definitely different from the true values
This can be resampled as follows.
```{r simple_resample_function}
set.seed(12345)
res <- resample_function(data_simple, simple_function)
res$estimates
```
The resampling returns better estimates.


## Statified Permutation

The following example demonstrates the use of `Purify` with simulated data that can be stratified. 
Consider some data with $150$ observations, with varying relationship to time, 
as simulated and plotted below.
```{r}
# Simulate data
set.seed(1234)
data <- rbind(
  data.frame('time'=runif(10,min=0,max=20),'group'=1),
  data.frame('time'=runif(140,min=0,max=20),'group'=2)
)
data$value <- ifelse(data$group==1,0.5,-0.5)*data$time + rnorm(nrow(data),sd=10)

plot(x=data$time,y=data$value,
     col=c('red','blue')[data$group], pch=c(3,20)[data$group])
```

Note that there is a real, contradictory effect from time for each group.
A natural place to start with some data is a linear model, and examining the 
coefficients.
```{r summary_function}
summ_function <- function(data) {
  coef(summary(lm(value ~ ., data = data)))
}
```

Run a linear model for the original data and each group.
```{r basic_regression}
summ_function(data)
summ_function(data[data$group==1,])
summ_function(data[data$group==2,])
```
On the entire data the intercept and time seems important, but groups cannot be 
distinquished due to data inbalance. The first group indicates time is not 
important, likely from the small sample. The second group find time highly
significant now. 

It can be hard to decide what is proper. Here resampling may be of value. We
consider the groups with stratified bootstrapping with the same size as the 
original and with the group sizes increased, perhaps due to domain knowledge.
```{r resamp_regression}
results_orig <- resample_function(data = data, fn = summ_function, 
                             M = 1000, method = 'stratify',
                             strata='group',stratify_sizes='original')
results_mean <- resample_function(data = data, fn = summ_function, 
                             M = 1000, method = 'stratify',
                             strata='group',stratify_sizes='mean')
```

Comparing to the original model:
```{r compare_models}
summ_function(data)
results_orig$estimates
results_mean$estimates
```
The originally sized group performs similarly to the linear model. However, 
increasing the groups, perhaps to correct for survey missampling, shows the 
groups are different, and time is now insignificant, which would be the true 
middle value.


## Dependent (Sliding / Segment) Permutation

Consider a dependent data set as generated below.
```{r dependent_generate}
set.seed(1234)
n <- 500

burnin <- 500
data_ts <- data.frame('Y'=rep(NA,n+burnin),
                      'X'=rnorm(n+burnin))
for(i in 1:(n+burnin)){
  if(i>5){
    data_ts$Y[i] <- data_ts$X[i] + sum(seq(5,3,-0.5)/10*data_ts$X[i-1:5]) + rnorm(1)
  }else{
    data_ts$Y[i] <- data_ts$X[i] + rnorm(1)
  }
}
data_ts <- data_ts[-(1:burnin),]

```

We could resample as follows.
```{r dependent_resample}
res <- resample(data = data_ts,method='sliding',blockSize = 5)
res1 <- resample(data_ts,method='segment',blockSize = 5)
```
